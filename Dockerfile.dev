
# Use an official Node.js runtime as a base image.
# This tells Docker to use an existing Node.js image as the base for our custom image. This base image has Node.js pre-installed.
FROM node:14-alpine AS development

# We set the node environment variable
ENV NODE_ENV development

# Set the current working directory inside the docker container to app
WORKDIR /app

# Copy package.json and package-lock.json to the working directory. This file contains the dependencies for our Node.js app.
COPY package*.json ./

# Cache and Install dependencies
# COPY yarn.lock .

#RUN yarn install
RUN npm install

# Copy everything from the current working directory of the host machine to the working directory inside the container ( which is app in this case ).
# This step is not necessary for the development Dockerfile though. We will map the host working directory to the containers working directory
# in the docker-compose.yml file anyway. But I like to keep this line here because in the future we may use this Dockerfile for production 
# or take this Dockerfile as an inspiration to create the production Dockerfile. 
# In that case, this line will work as a reminder that we need to copy the source code into the container.
COPY . .

# Expose the port the app runs on. This Informs Docker that the container will use port 3000
EXPOSE 3000

# This Specifies the command to Start the app
CMD [ "npm", "start" ]




# Create a docker-compose.dev.yml. Additionally, we will mount our code in a volume so that our code changes are in sync with the container during development.